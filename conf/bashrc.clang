# Distributed under the terms of the GNU General Public License v2
#
# Hook to make it easier to detect compiler output changes in src_configure with stricter Clang
# Outputs logs to /var/tmp/clang.
# Written by Sam James <sam@gentoo.org> and Arsen ArsenoviÄ‡ <arsen@aarsen.me>
#
# For background, please see https://wiki.gentoo.org/wiki/Modern_C_porting.
#
# Instructions:
# 1. Install clang:15 or clang:16
# 2. Install ansifilter
# 3. Two options:
#    - Set CC=clang and CXX=clang in make.conf
#    - If you don't want to build your system using Clang, set PORTAGE_USE_CLANG_HOOK_GCC=1 too.
#      This will run configure tests using Clang in 'pretend' mode in parallel
#      but the actual results used on your system should be your normal compiler.
# 4. File any bugs hit using this hook as a blocker for tracker bug #870412
#
# Variables:
# - PORTAGE_USE_CLANG_HOOK_GCC=1 to use gcc 'for real' but Clang for the testing

pre_src_prepare() {
	# If CC is set to something other than Clang, we shouldn't try
	# to override it (could even be done in the ebuild).
	if [[ -n ${CC} && ${CC} != *clang* ]] ; then
		return
	fi

	case ${EAPI} in
		012345)
			hv_args="--host-root"
			;;
		*)
			hv_args="-b"
			;;
	esac

	has_version ${hv_args} sys-devel/clang:15 && __PORTAGE_HOOK_CLANG=clang-15
	has_version ${hv_args} sys-devel/clang:16 && __PORTAGE_HOOK_CLANG=clang-16
	
	if ! type -P ansifilter &>/dev/null || ! type -P ${__PORTAGE_HOOK_CLANG} &>/dev/null ; then
		# Avoid issues in early setup when clang:15 or clang:16 haven't yet been emerged.
		export CC=gcc
		export CXX=g++
		return
	fi
}

pre_src_configure() {
	if [[ -n ${CC} && ${CC} != *clang* && -z ${PORTAGE_USE_CLANG_HOOK_GCC} ]] ; then
		return
	fi

	if ! type -P ansifilter &>/dev/null ; then
		return
	fi

	ewarn "Clang 16 testing: this build is using a /etc/portage/bashrc hook!"
	ewarn "Clang 16 testing: see https://wiki.gentoo.org/wiki/Modern_C_porting for more info."

	# Avoid noise from intentional ones...
	export ac_cv_c_undeclared_builtin_options="none needed"
	export gl_cv_compiler_check_decl_option="-Werror=implicit-function-declaration"

	if [[ ${CHOST} == *musl* ]] ; then
		if has_version dev-libs/libbsd ; then
			export ac_cv_func___fpurge=yes
			export ac_cv_func_fpurge=yes
			export ac_cv_have_decl_fpurge=no
			export gl_cv_func_fpurge_works=no
		fi

		# These should be fine on glibc IIRC but let's be safe until confirmed.
		export ac_cv_header_sys_types_h_makedev=no
		export gl_cv_minmax_in_limits_h=no
	fi

	# Weird hangs (see timeout comment below w/ tee)
	has waf-utils ${INHERITED} && return

	mkdir "${T}"/clang-wrappers
	cat <<- EOF > "${T}"/clang-wrappers/clang
	#!/usr/bin/env bash
	real_compiler=${__PORTAGE_HOOK_CLANG}
	
	if [[ -n \${PORTAGE_USE_CLANG_HOOK_GCC} ]] ; then
		real_compiler="${BROOT:-/}"/usr/bin/${CHOST}-gcc
	fi

	if [[ -n \${PORTAGE_CLANG_HOOK_USE_REAL_COMPILER} ]] ; then
		exec \${real_compiler} "\$@"
	fi

	# - Need > /dev/null for sys-libs/musl
	# - No LTO because of the noise it generates in diffs (temps)
	cl1() {
		${__PORTAGE_HOOK_CLANG} ${CFLAGS} -fno-lto -Wno-unused-command-line-argument -Wno-error=implicit-function-declaration -Wno-error=implicit-int -Wno-error=strict-prototypes \$@ 2>&1 | ansifilter | sed \
			-e "s:14.0.6:14.ignoreme:g" \
			-e "s:15.0.0:14.ignoreme:g" \
			-e "s:clang-\(14\|15\|16\):clang-ignoreme:g" \
			-e 's:clang version \([0-9]\+\)\.[0-9]\.[0-9]:clang version ignoreme:' \
			-e "s:/usr/lib/llvm/\(14\|15\|16\)/:/usr/lib/llvm/ignoreme/:g" \
			-e "s:conftest-.*\.o:conftest.o:g" \
			-e "s_conftest\.c\:[0-9]\+\:[0-9]\+_ignoreme_g" \
			-e "s:garbage2:ignoreme:" \
			-e "s:garbage:ignoreme:" \
			-e "/ac_nonexistent.h/d" \
			-e '/clang-\(14\|15\|16\|ignoreme\): error: no input files/d' \
			-e '/clang-\(14\|15\|16\|ignoreme\): error: unsupported option/d' \
			-e '/clang-\(14\|15\|16\|ignoreme\): error: unknown argument/d' \
			-e '/clang-\(14\|15\|16\|ignoreme\): error: no such file or directory/d' \
			-e '/clang-\(14\|15\|16\|ignoreme\): error: linker command failed/d' \
			-e '/[0-9]\+ \(warning\|error\) generated/d' | tee -a "${T}"/clang16-safe.log > /dev/null

		if ! [[ \${PIPESTATUS[0]} -eq 0 ]] ; then
			touch "${T}"/clang16-safe-failed
		fi
	}
	# TODO: No -Werror=strict-prototypes here for now as AC_PROG_LEX, AC_CHECK_FUNCS rely on it
	# also, I think Clang 15.0.1 (which reverts the other bits) keeps that in anyway.
	cl2() {
		${__PORTAGE_HOOK_CLANG} ${CFLAGS} -fno-lto -Wno-unused-command-line-argument -Werror=implicit-function-declaration -Werror=implicit-int \$@ 2>&1 | ansifilter | sed \
			-e "s:14.0.6:14.ignoreme:g" \
			-e "s:15.0.0:14.ignoreme:g" \
			-e "s:clang-\(14\|15\|16\):clang-ignoreme:g" \
			-e 's:clang version \([0-9]\+\)\.[0-9]\.[0-9]:clang version ignoreme:' \
			-e "s:/usr/lib/llvm/\(14\|15\|16\)/:/usr/lib/llvm/ignoreme/:g" \
			-e "s:15:14:g" \
			-e "s:conftest-.*\.o:conftest.o:g" \
			-e "s_conftest\.c\:[0-9]\+\:[0-9]\+_ignoreme_g" \
			-e "s:garbage2:ignoreme:" \
			-e "s:garbage:ignoreme:" \
			-e "/ac_nonexistent.h/d" \
			-e '/clang-\(14\|15\|16\|ignoreme\): error: no input files/d' \
			-e '/clang-\(14\|15\|16\|ignoreme\): error: unsupported option/d' \
			-e '/clang-\(14\|15\|16\|ignoreme\): error: unknown argument/d' \
			-e '/clang-\(14\|15\|16\|ignoreme\): error: no such file or directory/d' \
			-e '/clang-\(14\|15\|16\|ignoreme\): error: linker command failed/d' \
			-e '/[0-9]\+ \(warning\|error\) generated/d' | tee -a "${T}"/clang16-errors.log > /dev/null

		if ! [[ \${PIPESTATUS[0]} -eq 0 ]] ; then
			touch "${T}"/clang16-errors-failed
		fi
	}

	# Safety net against recursive calls
	export PORTAGE_CLANG_HOOK_USE_REAL_COMPILER=1

	# - Just run it again as it's easier for anything which wants to parse stdout/stderr,
	# and we're not concerned about performance for this experiment anyway.
	# - We have to do the tee & pipe dance to not greedily consume stdin: bug 870985.
	# - Timeout as a safety net because we don't ever want to make a build hang. Occurs
	# with waf sometimes (being investigated), but we should keep the timeout after that anyway.
	timeout --preserve-status -s PIPE 10 tee >(cl1 "\$@" -o "${T}"/garbage.\$\$) >(cl2 "\$@" -o "${T}"/garbage2.\$\$) | \${real_compiler} "\$@"
	ret="\${PIPESTATUS[1]}"

	# If at least one of them succeeded, then complain if *only* one of them did.
	if [[ -f "${T}"/clang16-safe-failed || -f "${T}"/clang16-errors-failed ]] ; then
		if ! [[ -f "${T}"/clang16-safe-failed && -f "${T}"/clang16-errors-failed ]] ; then
			touch "${T}"/clang16-broken
		fi
	fi

	rm -f "${T}"/clang16-safe-failed "${T}"/clang16-errors-failed
	exit \${ret}
	EOF

	chmod +x "${T}"/clang-wrappers/clang

	if in_iuse clang ; then
		# If an ebuild is trying to force compiler choice, it gets tricky
		# when we interfere with it. It's easier to just leave things be.
		# Firefox for example will get confused in its homebrew configure script.
		:;
	else
		# TODO: cc, ${CHOST}-cc?
		for alias in ${CHOST}-gcc gcc ${CHOST}-clang ; do
			ln -s "${T}"/clang-wrappers/clang "${T}"/clang-wrappers/${alias} || exit 1
			chmod +x "${T}"/clang-wrappers/${alias}
		done

		# -Werror=strict-prototypes
		export CFLAGS="${CFLAGS} -Werror=implicit-function-declaration -Werror=implicit-int"
		export PATH="${T}/clang-wrappers:${PATH}"
	fi
}

pre_src_compile() {
	if [[ -f "${T}"/clang16-errors.log ]] ; then
		rm -rf /var/tmp/clang/${CATEGORY}/${PF}
		mkdir -p /var/tmp/clang/${CATEGORY}/${PF}

		cp -rv "${T}"/clang16-{errors,safe}.log /var/tmp/clang/${CATEGORY}/${PF}

		if diff -ruN "${T}"/clang16-{safe,errors}.log > /var/tmp/clang/${CATEGORY}/${PF}/clang.diff ; then
			# No point in keeping an empty diff around if no differences.
			rm /var/tmp/clang/${CATEGORY}/${PF}/clang.diff
		fi

		[[ -f "${T}"/clang16-broken ]] && touch /var/tmp/clang/${CATEGORY}/${PF}/clang16-broken
	fi

	# We want to just delete the wrapper rather than mess with PATH again, as the ebuild
	# may have modified PATH itself.
	export PORTAGE_CLANG_HOOK_USE_REAL_COMPILER=1
	#rm -f "${T}"/clang-wrappers/{clang,gcc,cc,${CHOST}-gcc,${CHOST}-clang}
}
